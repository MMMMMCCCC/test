<!DOCTYPE html>
<html>
  <head>
    <title>Traffic Map</title>
    <meta name="viewport" content="initial-scale=1.0" />
    <meta charset="utf-8" />
    <style>
      html, body, #map {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      /* Travel-mode dropdown */
      #modeToggle {
        position: absolute; top: 10px; left: 50%;
        transform: translateX(-50%);
        background: #ADD8E6; padding: 12px 16px;
        border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        font-family: sans-serif; z-index:5;
      }
      #modeToggle label {
        font-size:18px; font-weight:bold; color:#0000CD;
        margin-right:8px;
      }
      #modeToggle select {
        font-size:18px; color:#0000CD; padding:4px;
      }
      /* Info box */
      #infoBox {
        position:absolute; bottom:60px; left:0; width:100%;
        background:rgba(255,255,255,0.9); padding:12px;
        font-family:sans-serif; font-size:20px; text-align:center;
        box-shadow:0 -2px 4px rgba(0,0,0,0.2); z-index:5;
      }
      #infoBox .distance { color:#FF8C00; font-weight:bold }
      #infoBox .duration { color:#008000; font-weight:bold }
      /* Buttons */
      .btn {
        position:absolute; padding:10px 14px; font-size:16px;
        border:none; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.3);
        cursor:pointer; z-index:5; background:#FFD700;
      }
      #reportBusy { bottom: 135px; right: 10px; }
      #destinationOverlay {
        position: absolute;
        top:   0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.5);
        display: none;                /* show via JS */
        align-items: center;          /* vertical centering */
        justify-content: center;      /* horizontal centering */
        z-index: 1000;                /* above the map */
      }
      #destinationOverlay .modal {
        background: white;
        padding: 24px 32px;
        border-radius: 8px;
        text-align: center;
        max-width: 80%;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      }
      #destinationOverlay .modal h2 {
        margin-top: 0;
        font-size: 22px;
      }
      #destinationOverlay .modal p {
        font-size: 16px;
        margin: 12px 0;
      }
    </style>
    <script>
      let map, directionsService, directionsRenderer;
      let currentCoords, startAndEndLocation, redArea, busyAreas;

      let notifiedDestination = false;
      let selectedMode = 'WALKING';
      let updateCount = 0;
      let distanceService;
      let currentMarker;
      let lastPanLocation = null;
      // add these
      let lastUserInteraction = 0;      // timestamp (ms) when user last touched/dragged/zoomed
      const autoPanDelay = 7000;        // don't auto-pan until X ms after last user interaction
      const panDistanceThreshold = 10;  // meters before we auto-pan (avoid jitter)


      function parseQueryParams() {
        const p = new URLSearchParams(window.location.search);
        const pj = s => JSON.parse(decodeURIComponent(s || '[]'));
      
        // live location passed from App Inventor
        currentCoords       = pj(p.get('currentCoords'));
        // static start+end passed from App Inventor
        startAndEndLocation = pj(p.get('startAndEndLocation'));
        // circles
        const rawRed  = pj(p.get('redArea'));
        const rawBusy = pj(p.get('busyAreas'));
      
        redArea   = rawRed .map(s => { const a = JSON.parse(s); return {lat:a[1],lng:a[0]}; }).filter(x=>x);
        busyAreas = rawBusy.map(a => ({lat:a[0],lng:a[1]}));
      }

      function initMap() {
        try {
          parseQueryParams();
          // If your URL‐encoded list is [ destLat, destLng, startLat, startLng ]:
          const [ destLat, destLng, startLat, startLng ] = startAndEndLocation;
          // inside initMap(), right after parseQueryParams() and destLat/destLng
          // DEBUG: send your parsed route endpoints back to App Inventor
          if (navigator.geolocation) {
            navigator.geolocation.watchPosition(pos => {
              currentCoords = [ pos.coords.latitude, pos.coords.longitude ];
            }, err => {
              console.warn("Geolocation error:", err);
            }, {
              enableHighAccuracy: true,
              maximumAge: 0,
              timeout: 5000
            });
          }
          map = new google.maps.Map(document.getElementById('map'), {
            center:{lat:currentCoords[0],lng:currentCoords[1]}, zoom:16
          });
          // mark the time whenever user interacts with the map
          function markUserInteraction() { lastUserInteraction = Date.now(); }
          map.addListener('dragstart', markUserInteraction);
          map.addListener('mousedown', markUserInteraction);
          map.addListener('touchstart', markUserInteraction);
          map.addListener('zoom_changed', markUserInteraction);
          // 'idle' fires after move/zoom completes — record that too
          map.addListener('idle', () => { lastUserInteraction = Date.now(); });

          // Traffic layer
          new google.maps.TrafficLayer().setMap(map);
          directionsService  = new google.maps.DirectionsService();
          directionsRenderer = new google.maps.DirectionsRenderer({
            map: map,
            preserveViewport: true
          });
  
          // Blue marker = current location
          currentMarker = new google.maps.Marker({
            position: { lat: currentCoords[0], lng: currentCoords[1] },
            map: map,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 8,
              fillColor: '#4285F4',
              fillOpacity: 1,
              strokeWeight: 2,
              strokeColor: 'white'
            }
          });
          
          // Set up DistanceMatrixService
          distanceService = new google.maps.DistanceMatrixService();
  
          // Danger circles
          redArea.forEach(c => {
            new google.maps.Circle({
              map: map,
              center: c,               // use the object directly
              radius: 600,             // a bit larger for visibility
              strokeColor: '#FF0000',
              strokeOpacity: 0.9,
              strokeWeight: 2,
              fillColor: '#FF6666',
              fillOpacity: 0.4,
              zIndex: 1000             // draw above roads
            });
          });
  
          // Busy-area circles (yellow)
          if (busyAreas.length) busyAreas.forEach(c =>
            new google.maps.Circle({
              map: map,
              center: c,
              radius: 100,               // bigger radius
              strokeColor: '#FFD700',    // bright gold border
              strokeOpacity: 1,          // fully opaque border
              strokeWeight: 2,           // thicker border
              fillColor: '#FFFF00',      // pure yellow fill
              fillOpacity: 0.4,          // more visible
              zIndex: 1002               // above everything else
            })
          );
  
          // Draw walking route
          calculateAndDisplayRoute(startAndEndLocation, selectedMode);
  
          // Travel-mode toggle
          document.getElementById('travelMode')
            .addEventListener('change', e => {
              selectedMode = e.target.value;
              calculateAndDisplayRoute(startAndEndLocation, selectedMode);
            });
  
          // Report Busy button
          document.getElementById('reportBusy')
            .addEventListener('click', () => {
              if (window.AppInventor) {
                window.AppInventor.setWebViewString(JSON.stringify({
                  reportBusy: true,
                  lat: currentCoords[0],
                  lng: currentCoords[1]
                }));
              }
            });  // ← close the click-function and addEventListener
          
          // Check proximity every 5s
          // Inside your initMap(), replace or add the following setInterval section:

          setInterval(() => {
            // 1) bump the tick counter
            updateCount++;
          
            if (updateCount > 1) {
              // 1) Move the blue marker
              currentMarker.setPosition({
                lat: currentCoords[0],
                lng: currentCoords[1]
              });
          
              // 2) Pan the map (after 7s)
              if (updateCount > 7) {
                const newLatLng = new google.maps.LatLng(currentCoords[0], currentCoords[1]);
              
                // moved enough distance?
                const movedFarEnough = !lastPanLocation ||
                  google.maps.geometry.spherical.computeDistanceBetween(newLatLng, lastPanLocation) > panDistanceThreshold;
              
                // enough time since user's last interaction?
                const timeSinceUser = Date.now() - lastUserInteraction;
                const userIsIdle = timeSinceUser > autoPanDelay;
              
                if (movedFarEnough && userIsIdle) {
                  map.panTo(newLatLng);
                  lastPanLocation = newLatLng;
                }
              }

              // 3) Distance & duration only
              distanceService.getDistanceMatrix({
                origins:      [{ lat: currentCoords[0], lng: currentCoords[1] }],
                destinations: [{ lat: destLat,        lng: destLng        }],
                travelMode:   selectedMode,
                unitSystem: google.maps.UnitSystem.IMPERIAL
              }, (response, status) => {
                if (status === 'OK') {
                  const el = response.rows[0].elements[0];
                  document.getElementById('infoBox').innerHTML =
                    `<span class="distance">Distance: ${el.distance.text}</span>` +
                    ` &nbsp;•&nbsp; ` +
                    `<span class="duration">Duration: ${el.duration.text}</span>`;
                }
              });
            }
            // 3) check all busyAreas every tick
            busyAreas.forEach(c => {
              const d = google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(currentCoords[0], currentCoords[1]),
                new google.maps.LatLng(c.lat, c.lng)
              );
              if (d < 50 && window.AppInventor) {
                window.AppInventor.setWebViewString(JSON.stringify({
                  approachingBusy: true,
                  lat: c.lat,
                  lng: c.lng
                }));
              }
            });
          
            // 4) check all redArea every tick
            redArea.forEach(c => {
              const d = google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(currentCoords[0], currentCoords[1]),
                new google.maps.LatLng(c.lat, c.lng)
              );
              if (d < 50 && window.AppInventor) {
                window.AppInventor.setWebViewString(JSON.stringify({
                  approachingRed: true,
                  lat: c.lat,
                  lng: c.lng
                }));
              }
            });
          
            // 5) arrival check *only after* 3 ticks
            if (updateCount > 3) {
              const destDistance = google.maps.geometry.spherical.computeDistanceBetween(
                new google.maps.LatLng(currentCoords[0], currentCoords[1]),
                new google.maps.LatLng(destLat, destLng)
              );
              if (!notifiedDestination && destDistance < 30) {
                notifiedDestination = true;
                document.getElementById('destinationOverlay').style.display = 'flex';
                if (window.AppInventor) {
                  window.AppInventor.setWebViewString(
                    JSON.stringify({ reachedDestination: true })
                  );
                }
              }
            }
          }, 1000);
        } catch (e) {
    // Handle any errors initializing the map
          if (window.AppInventor) {
            window.AppInventor.setWebViewString(
              JSON.stringify({ mapInitError: e.message })
            );
          }
          console.error('initMap error:', e);
        }
      }

      function calculateAndDisplayRoute([sLat,sLng,eLat,eLng], mode) {
        directionsService.route({
          origin:{lat:sLat,lng:sLng},
          destination:{lat:eLat,lng:eLng},
          travelMode:mode
        },(res,st)=>{
          if(st==='OK'){
            directionsRenderer.setDirections(res);
            const leg=res.routes[0].legs[0];
            document.getElementById('infoBox').innerHTML=
              `<span class="distance">Distance: ${leg.distance.text}</span>`+
              ` &nbsp;•&nbsp; `+
              `<span class="duration">Duration: ${leg.duration.text}</span>`;
            if(window.AppInventor)
              window.AppInventor.setWebViewString(
                JSON.stringify({
                  distance:leg.distance.text,
                  duration:leg.duration.text
                })
              );
          }
        });
      }
      function hideDestinationOverlay() {
        document.getElementById('destinationOverlay').style.display = 'none';
      }
    </script>
  </head>
  <body>
    <div id="modeToggle">
      <label for="travelMode">Travel Mode:</label>
      <select id="travelMode">
        <option value="WALKING" selected>Walking</option>
        <option value="BICYCLING">Bicycling</option>
        <option value="DRIVING">Driving</option>
      </select>
    </div>
    <div id="map"></div>
    <button id="reportBusy" class="btn">Report Busy</button>
    <div id="infoBox">
      <span class="distance">Distance: --</span> &nbsp;•&nbsp;
      <span class="duration">Duration: --</span>
    </div>
    <div id="destinationOverlay">
      <div class="modal">
        <h2>You’ve reached your destination!</h2>
        <p>Tap “End Navigation” in the app to close.</p>
      </div>
    </div>
    <script async defer
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBN3F8_sdEGAIkhBVDx5ImQLm4SDW5SSlU&libraries=geometry&callback=initMap">
    </script>
  </body>
</html>

