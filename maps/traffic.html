<!DOCTYPE html>
<html>
  <head>
    <title>Traffic Map</title>
    <meta name="viewport" content="initial-scale=1.0" />
    <meta charset="utf-8" />
    <style>
      html, body, #map {
        height: 100%;
        margin: 0;
        padding: 0;
      }
      /* Travel-mode dropdown */
      #modeToggle {
        position: absolute; top: 10px; left: 50%;
        transform: translateX(-50%);
        background: #ADD8E6; padding: 12px 16px;
        border-radius: 8px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        font-family: sans-serif; z-index:5;
      }
      #modeToggle label {
        font-size:18px; font-weight:bold; color:#0000CD;
        margin-right:8px;
      }
      #modeToggle select {
        font-size:18px; color:#0000CD; padding:4px;
      }
      /* Info box */
      #infoBox {
        position:absolute; bottom:60px; left:0; width:100%;
        background:rgba(255,255,255,0.9); padding:12px;
        font-family:sans-serif; font-size:20px; text-align:center;
        box-shadow:0 -2px 4px rgba(0,0,0,0.2); z-index:5;
      }
      #infoBox .distance { color:#FF8C00; font-weight:bold }
      #infoBox .duration { color:#008000; font-weight:bold }
      /* Buttons */
      .btn {
        position:absolute; padding:10px 14px; font-size:16px;
        border:none; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.3);
        cursor:pointer; z-index:5; background:#FFD700;
      }
      #reportBusy { bottom: 135px; right: 10px; }
      #destinationOverlay {
        position: absolute;
        top:   0; left: 0;
        width: 100%; height: 100%;
        background: rgba(0,0,0,0.5);
        display: none;                /* show via JS */
        align-items: center;          /* vertical centering */
        justify-content: center;      /* horizontal centering */
        z-index: 1000;                /* above the map */
      }
      #destinationOverlay .modal {
        background: white;
        padding: 24px 32px;
        border-radius: 8px;
        text-align: center;
        max-width: 80%;
        box-shadow: 0 4px 10px rgba(0,0,0,0.3);
      }
      #destinationOverlay .modal h2 {
        margin-top: 0;
        font-size: 22px;
      }
      #destinationOverlay .modal p {
        font-size: 16px;
        margin: 12px 0;
      }
    </style>
    <script>
      let map, directionsService, directionsRenderer;
      // sensible defaults so we never pass undefined into Google calls
      let currentCoords = [0, 0];
      let startAndEndLocation = [];
      let redArea = [];
      let busyAreas = [];

      let notifiedDestination = false;
      let selectedMode = 'WALKING';
      let updateCount = 0;
      let distanceService;
      let currentMarker;
      let lastPanLocation = null;
      // add these
      let lastUserInteraction = 0;      // timestamp (ms) when user last touched/dragged/zoomed
      const autoPanDelay = 7000;        // don't auto-pan until X ms after last user interaction
      const panDistanceThreshold = 10;  // meters before we auto-pan (avoid jitter)

      function parseQueryParams() {
        const p = new URLSearchParams(window.location.search);
        const pj = s => {
          try {
            if (!s) return [];
            // some callers double-encode; try decode then JSON.parse
            return JSON.parse(decodeURIComponent(s));
          } catch (e) {
            // last resort: try raw parse (maybe it's already an array/object)
            try { return JSON.parse(s); } catch(e2) { return []; }
          }
        };

        // live location passed from App Inventor
        const cc = pj(p.get('currentCoords'));
        if (Array.isArray(cc) && cc.length >= 2) currentCoords = cc;

        // static start+end passed from App Inventor
        const sae = pj(p.get('startAndEndLocation'));
        if (Array.isArray(sae)) startAndEndLocation = sae;

        // circles: raw entries may be stringified arrays or arrays
        const rawRed  = pj(p.get('redArea')) || [];
        const rawBusy = pj(p.get('busyAreas')) || [];

        redArea = (Array.isArray(rawRed) ? rawRed : []).map(item => {
          try {
            const a = (typeof item === 'string') ? JSON.parse(item) : item;
            if (!Array.isArray(a)) return null;
            // decide which index is latitude (latitude is in -90..90)
            return (Math.abs(a[0]) <= 90) ? { lat: a[0], lng: a[1] } : { lat: a[1], lng: a[0] };
          } catch (e) { return null; }
        }).filter(Boolean);

        busyAreas = (Array.isArray(rawBusy) ? rawBusy : []).map(item => {
          try {
            const a = (typeof item === 'string') ? JSON.parse(item) : item;
            if (Array.isArray(a) && a.length >= 2) {
              return (Math.abs(a[0]) <= 90) ? { lat: a[0], lng: a[1] } : { lat: a[1], lng: a[0] };
            }
            if (a && a.lat !== undefined && a.lng !== undefined) return { lat: a.lat, lng: a.lng };
            return null;
          } catch (e) { return null; }
        }).filter(Boolean);
      }

      function initMap() {
        try {
          parseQueryParams();

          // Normalize start/end coords - accept either [sLat,sLng,eLat,eLng] OR [destLat,destLng,startLat,startLng]
          let sLat, sLng, eLat, eLng;
          if (startAndEndLocation && startAndEndLocation.length === 4) {
            // If first element looks like a latitude (-90..90), assume [sLat,sLng,eLat,eLng]
            if (Math.abs(startAndEndLocation[0]) <= 90) {
              [sLat, sLng, eLat, eLng] = startAndEndLocation;
            } else {
              // otherwise fallback to previous ordering used elsewhere
              [eLat, eLng, sLat, sLng] = startAndEndLocation;
            }
          } else {
            // leave as undefined if not present
          }

          // Determine initial center: prefer currentCoords, then start, then end, else 0,0
          const center = {
            lat: (currentCoords && currentCoords[0]) ? currentCoords[0] : (sLat || eLat || 0),
            lng: (currentCoords && currentCoords[1]) ? currentCoords[1] : (sLng || eLng || 0)
          };

          map = new google.maps.Map(document.getElementById('map'), {
            center,
            zoom: 16
          });

          // mark the time whenever user interacts with the map
          function markUserInteraction() { lastUserInteraction = Date.now(); }
          map.addListener('dragstart', markUserInteraction);
          map.addListener('mousedown', markUserInteraction);
          map.addListener('touchstart', markUserInteraction);
          map.addListener('zoom_changed', markUserInteraction);
          // 'idle' fires after move/zoom completes — record that too
          map.addListener('idle', () => { lastUserInteraction = Date.now(); });

          // Traffic layer
          new google.maps.TrafficLayer().setMap(map);
          directionsService  = new google.maps.DirectionsService();
          directionsRenderer = new google.maps.DirectionsRenderer({
            map: map,
            preserveViewport: true
          });

          // Blue marker = current location
          currentMarker = new google.maps.Marker({
            position: { lat: currentCoords[0], lng: currentCoords[1] },
            map: map,
            icon: {
              path: google.maps.SymbolPath.CIRCLE,
              scale: 8,
              fillColor: '#4285F4',
              fillOpacity: 1,
              strokeWeight: 2,
              strokeColor: 'white'
            }
          });

          // Set up DistanceMatrixService
          distanceService = new google.maps.DistanceMatrixService();

          // Danger circles
          redArea.forEach(c => {
            new google.maps.Circle({
              map: map,
              center: c,
              radius: 600,
              strokeColor: '#FF0000',
              strokeOpacity: 0.9,
              strokeWeight: 2,
              fillColor: '#FF6666',
              fillOpacity: 0.4,
              zIndex: 1000
            });
          });

          // Busy-area circles (yellow)
          if (busyAreas.length) busyAreas.forEach(c =>
            new google.maps.Circle({
              map: map,
              center: c,
              radius: 100,
              strokeColor: '#FFD700',
              strokeOpacity: 1,
              strokeWeight: 2,
              fillColor: '#FFFF00',
              fillOpacity: 0.4,
              zIndex: 1002
            })
          );

          // Draw walking route only if we have full start & end
          if (typeof sLat !== 'undefined' && typeof sLng !== 'undefined' &&
              typeof eLat !== 'undefined' && typeof eLng !== 'undefined') {
            calculateAndDisplayRoute([sLat, sLng, eLat, eLng], selectedMode);
          }

          // Travel-mode toggle
          document.getElementById('travelMode')
            .addEventListener('change', e => {
              selectedMode = e.target.value;
              if (typeof sLat !== 'undefined' && typeof sLng !== 'undefined' &&
                  typeof eLat !== 'undefined' && typeof eLng !== 'undefined') {
                calculateAndDisplayRoute([sLat, sLng, eLat, eLng], selectedMode);
              }
            });

          // Report Busy button
          document.getElementById('reportBusy')
            .addEventListener('click', () => {
              if (window.AppInventor) {
                window.AppInventor.setWebViewString(JSON.stringify({
                  reportBusy: true,
                  lat: currentCoords[0],
                  lng: currentCoords[1]
                }));
              }
            });

          // Watch device geolocation if available (updates currentCoords)
          if (navigator.geolocation) {
            navigator.geolocation.watchPosition(pos => {
              currentCoords = [ pos.coords.latitude, pos.coords.longitude ];
            }, err => {
              console.warn("Geolocation error:", err);
            }, {
              enableHighAccuracy: true,
              maximumAge: 0,
              timeout: 5000
            });
          }

          // main tick: update marker, check proximity, distance matrix etc.
          setInterval(() => {
            updateCount++;

            if (updateCount > 1) {
              // move marker (safe positions)
              const newLat = currentCoords[0] || center.lat;
              const newLng = currentCoords[1] || center.lng;
              const newPos = { lat: newLat, lng: newLng };
              currentMarker.setPosition(newPos);

              // PAN: only if enough time has passed since user last interacted AND moved > threshold
              if (updateCount > 7) {
                const newLatLng = new google.maps.LatLng(newPos.lat, newPos.lng);

                const movedFarEnough = !lastPanLocation ||
                  google.maps.geometry.spherical.computeDistanceBetween(newLatLng, lastPanLocation) > panDistanceThreshold;

                const timeSinceUser = Date.now() - lastUserInteraction;
                const userIsIdle = timeSinceUser > autoPanDelay;

                if (movedFarEnough && userIsIdle) {
                  map.panTo(newLatLng);
                  lastPanLocation = newLatLng;
                }
              }

              // Distance Matrix for display (IMPERIAL units)
              // Only if we have a destination
              if (typeof eLat !== 'undefined' && typeof eLng !== 'undefined') {
                distanceService.getDistanceMatrix({
                  origins:      [{ lat: newPos.lat, lng: newPos.lng }],
                  destinations: [{ lat: eLat,        lng: eLng        }],
                  travelMode:   selectedMode,
                  unitSystem: google.maps.UnitSystem.IMPERIAL
                }, (response, status) => {
                  if (status === 'OK' &&
                      response.rows && response.rows[0] &&
                      response.rows[0].elements && response.rows[0].elements[0] &&
                      response.rows[0].elements[0].status === 'OK') {
                    const el = response.rows[0].elements[0];
                    document.getElementById('infoBox').innerHTML =
                      `<span class="distance">Distance: ${el.distance.text}</span>` +
                      ` &nbsp;•&nbsp; ` +
                      `<span class="duration">Duration: ${el.duration.text}</span>`;
                    if (window.AppInventor) {
                      window.AppInventor.setWebViewString(
                        JSON.stringify({ distance: el.distance.text, duration: el.duration.text })
                      );
                    }
                  }
                });
              }
            }

            // check busyAreas and redArea
            const curLatLng = new google.maps.LatLng(currentCoords[0] || center.lat, currentCoords[1] || center.lng);
            busyAreas.forEach(c => {
              const d = google.maps.geometry.spherical.computeDistanceBetween(curLatLng, new google.maps.LatLng(c.lat, c.lng));
              if (d < 50 && window.AppInventor) {
                window.AppInventor.setWebViewString(JSON.stringify({
                  approachingBusy: true,
                  lat: c.lat,
                  lng: c.lng
                }));
              }
            });
            redArea.forEach(c => {
              const d = google.maps.geometry.spherical.computeDistanceBetween(curLatLng, new google.maps.LatLng(c.lat, c.lng));
              if (d < 50 && window.AppInventor) {
                window.AppInventor.setWebViewString(JSON.stringify({
                  approachingRed: true,
                  lat: c.lat,
                  lng: c.lng
                }));
              }
            });

            // arrival check (after a few ticks)
            if (updateCount > 3 && typeof eLat !== 'undefined' && typeof eLng !== 'undefined') {
              const destDistance = google.maps.geometry.spherical.computeDistanceBetween(
                curLatLng,
                new google.maps.LatLng(eLat, eLng)
              );
              if (!notifiedDestination && destDistance < 30) {
                notifiedDestination = true;
                document.getElementById('destinationOverlay').style.display = 'flex';
                if (window.AppInventor) {
                  window.AppInventor.setWebViewString(JSON.stringify({ reachedDestination: true }));
                }
              }
            }
          }, 1000); // 1s tick

        } catch (e) {
          if (window.AppInventor) {
            window.AppInventor.setWebViewString(JSON.stringify({ mapInitError: e.message }));
          }
          console.error('initMap error:', e);
        }
      }

      function calculateAndDisplayRoute([sLat,sLng,eLat,eLng], mode) {
        if (!directionsService) return;
        // guard: ensure numbers present
        if (typeof sLat === 'undefined' || typeof sLng === 'undefined' ||
            typeof eLat === 'undefined' || typeof eLng === 'undefined') return;

        directionsService.route({
          origin:{lat:sLat,lng:sLng},
          destination:{lat:eLat,lng:eLng},
          travelMode:mode
        },(res,st)=>{
          if(st==='OK'){
            directionsRenderer.setDirections(res);
            const leg=res.routes[0].legs[0];
            document.getElementById('infoBox').innerHTML=
              `<span class="distance">Distance: ${leg.distance.text}</span>`+
              ` &nbsp;•&nbsp; `+
              `<span class="duration">Duration: ${leg.duration.text}</span>`;
            if(window.AppInventor)
              window.AppInventor.setWebViewString(
                JSON.stringify({
                  distance:leg.distance.text,
                  duration:leg.duration.text
                })
              );
          } else {
            console.warn('Directions failed:', st);
          }
        });
      }
      function hideDestinationOverlay() {
        document.getElementById('destinationOverlay').style.display = 'none';
      }
    </script>
  </head>
  <body>
    <div id="modeToggle">
      <label for="travelMode">Travel Mode:</label>
      <select id="travelMode">
        <option value="WALKING" selected>Walking</option>
        <option value="BICYCLING">Bicycling</option>
        <option value="DRIVING">Driving</option>
      </select>
    </div>
    <div id="map"></div>
    <button id="reportBusy" class="btn">Report Busy</button>
    <div id="infoBox">
      <span class="distance">Distance: --</span> &nbsp;•&nbsp;
      <span class="duration">Duration: --</span>
    </div>
    <div id="destinationOverlay">
      <div class="modal">
        <h2>You’ve reached your destination!</h2>
        <p>Tap “End Navigation” in the app to close.</p>
      </div>
    </div>
    <script async defer
      src="https://maps.googleapis.com/maps/api/js?key=AIzaSyBN3F8_sdEGAIkhBVDx5ImQLm4SDW5SSlU&libraries=geometry&callback=initMap">
    </script>
  </body>
</html>
